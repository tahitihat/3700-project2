#!/usr/bin/env python3
"""
Project 2 Submission for CS3700
Caitlin Wang and Isabel Tripp (Team Blonco)

Based on provided starter code
"""

import argparse
import json
import select
import socket
import ipaddress
import operator
from functools import reduce

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# Internal Route Info
CUST = "cust"
PEER = "peer"
PROV = "prov"

# Route Origin Info
IGP = 'IGP'
EGP = 'EGP'
UNK = 'UNK'

# Util
NXHP = 'next_hop'

##########################################################################################

class Router:
  """ Router constructor """

  def __init__(self, asn, networks):
    self.asn = asn
    self.routes = {}
    self.updates = []
    self.relations = {}
    self.sockets = {}
    for relationship in networks:
      network, relation = relationship.split('-')
      self.sockets[network] = socket.socket(
          socket.AF_UNIX, socket.SOCK_SEQPACKET)
      self.sockets[network].setblocking(0)
      self.sockets[network].connect(network)
      self.relations[network] = relation


  def lookup_routes(self, daddr):
    """ Look up all valid routes for an address """
    outroutes = []
    for net, routes in self.routes.items():
      network = net[0]
      netmask = net[1]
      route_network = ipaddress.ip_network(network + '/' + netmask, strict=False)
      if ipaddress.ip_address(daddr) in route_network: 
        outroutes.append(routes)
    return reduce(operator.concat, outroutes)

  def get_shortest_as_path(self, routes):
    """ Select the route with the shortest AS Path """
    outroutes = []
    shortest_len = 100000 #TODO better selection algorithm
    for route in routes:
      as_path = route.get(APTH)
      as_path_len = len(as_path)
      # If ASpath shorter, update outroutes and shortest_len
      if as_path_len < shortest_len:
        shortest_len = as_path_len
        outroutes = [route]
      # If ASpath equal, append route to outroutes
      elif as_path_len == shortest_len:
        outroutes.append(route)

    return outroutes

  def get_highest_preference(self, routes):
    """ Select the route with the highest localPref """
    outroutes = []
    highest_pref = 0
    for route in routes:
      localpref = route.get(LPRF)
      # If localpref higher, update outroutes and highest_pref
      if localpref > highest_pref:
        highest_pref = localpref
        outroutes = [route]
      # If localpref equal, append route to outroutes
      elif localpref == highest_pref:
        outroutes.append(route)

    return outroutes


  def get_self_origin(self, routes):
    """ Select self originating routes """
    sorg_routes = [route for route in routes if route.get(SORG)]
    return sorg_routes if len(sorg_routes) > 0 else routes


  def compare_higher_origin(self, origin1, origin2):
    """
      Compare two origins based on precedence IGP > EGP > UNK
      <0 o1 is more preferable than o2
      0 o1 is equivalent to o2
      >1 o1 is less preferable than o2
    """
    if origin1 == IGP:
      val = 0 if origin2 == IGP else -1
    elif origin1 == EGP:
      if origin2 == IGP:
        val = 1
      elif origin2 == EGP:
        val = 0
      elif origin2 == UNK:
        val = -1
    elif origin1 == UNK:
      val = 0 if origin2 == UNK else 1

    return val


  def get_origin_routes(self, routes):
    """ Select origin routes: IGP > EGP > UNK """
    outroutes = []
    best_origin = UNK
    for route in routes:
      origin = route.get(ORIG)
      origin_comparison = self.compare_higher_origin(origin, best_origin)
      # If origin better, update outroutes and best_origin
      if origin_comparison < 0:
        best_origin = origin
        outroutes = [route]
      # If origin equal, append route to outroutes
      elif origin_comparison == 0:
        outroutes.append(route)

    return outroutes


  def filter_relationships(self, srcif, routes):
    """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
    outroutes = []
    return outroutes


  def get_route(self, srcif, daddr):
    """ Select the best route for a given address """
    routes = self.lookup_routes(daddr)
    peer = None
    # Rules go here
    if routes:
      # 1. Highest Preference
      routes = self.get_highest_preference(routes)
      # 2. Self Origin
      routes = self.get_self_origin(routes)
      # 3. Shortest ASPath
      routes = self.get_shortest_as_path(routes)
      # 4. EGP > IGP > UNK
      routes = self.get_origin_routes(routes)
      # 5. Lowest IP Address
      # TODO
      # Final check: enforce peering relationships
      # routes = self.filter_relationships(srcif, routes)
    
    if len(routes) > 0: 
      peer = routes[0].get(NXHP)
    return self.sockets[peer] if peer else None


  def forward(self, srcif, packet):
    """ Forward a data packet """
    dst = packet[DEST]
    
    # Find the socket that matches the destination
    try:
      conn = self.get_route(srcif, dst)      
      if conn is not None:
        conn.sendall(json.dumps(packet).encode())
      else: 
        return False
    except:
      raise Exception('Failed to forward data packet')
    return True


  def coalesce(self):
    """ coalesce any routes that are right next to each other """
    # TODO (this is the most difficult task, save until last)
    return False


  def update(self, srcif, packet):
    """ Handle update packets """
    # Save copy of the route announcement
    self.updates.append(packet)

    # Update forwarding table
    src = packet[SRCE]
    dst = packet[DEST]

    aspath = packet[MESG][APTH]
    network = packet[MESG][NTWK]
    netmask = packet[MESG][NMSK]
    localpref = packet[MESG][LPRF]
    origin = packet[MESG][ORIG]
    self_origin = packet[MESG][SORG]

    route_info = {NXHP: src, APTH: aspath, LPRF: localpref, ORIG: origin, SORG: self_origin}

    #print(network)
    #print(netmask)
    #print(route_info)
    #print('\n')

    
    if (network, netmask) not in self.routes:
      self.routes[(network, netmask)] = [route_info]
    else:
      self.routes[(network, netmask)].append(route_info)

    # Send announcement to neighboring routers
    aspath.append(self.asn)
    packet[MESG][APTH] = aspath

    for sock, conn in self.sockets.items():
        if not src == sock:
          packet[DEST] = sock
          packet[SRCE] = (ipaddress.ip_address(sock) - 1).exploded
          try:
            conn.sendall(json.dumps(packet).encode())
          except:
            raise Exception('Failed to forward update announcement to neighbor')

    return True


  def revoke(self, packet):
    """ handle revoke packets """
    # TODO
    return True


  def dump(self, packet):
    """ Handles dump table requests """
    src = packet[SRCE]
    dst = packet[DEST]
    
    # Build the table message based on contents of routing table
    table_dict = []
    for net, route_list in self.routes.items():
      for route in route_list:
        table_item = {NTWK: net[0], NMSK: net[1], PEER: route.get(NXHP)}
        table_dict.append(table_item)

    table_packet = {SRCE: dst, DEST: src, TYPE: 'table', MESG: table_dict}

    # Send the table packet to the router requesting it
    try:
      conn = self.sockets[src]
      conn.sendall(json.dumps(table_packet).encode())
    except:
      raise Exception('Faled to send forwarding table to requester')

    return True


  def handle_packet(self, srcif, packet):
    """ Dispatches a packet """
    status = False

    if packet[TYPE] == UPDT:
      status = self.update(srcif, packet)
    elif packet[TYPE] == DATA:
      status = self.forward(srcif, packet)
    elif packet[TYPE] == DUMP:
      status = self.dump(packet)

    return status


  def send_error(self, conn, msg):
    """ Send a no_route error message """
    packet_src = msg[SRCE]
    packet_dst = msg[DEST]
    error_msg = {SRCE: packet_src, DEST: packet_dst, TYPE: 'no route', MESG: {}}
    try:    
      conn.sendall(json.dumps(error_msg).encode())
    except:
      raise Exception('Failed to send error')


  def run(self):
    """ Main loop for the router """
    while True:
      socks = select.select(self.sockets.values(), [], [], 0.1)[0]
      for conn in socks:
        try:
          k = conn.recv(65535)
        except:
          # either died on a connection reset, or was SIGTERM's by parent
          return
        if k:
          for sock in self.sockets:
            if self.sockets[sock] == conn:
              srcif = sock
          msg = json.loads(k)
          if not self.handle_packet(srcif, msg):
            self.send_error(conn, msg)
        else:
          return


if __name__ == "__main__":
  PARSER = argparse.ArgumentParser(description='route packets')
  PARSER.add_argument('asn', type=int, help="AS number")
  PARSER.add_argument('networks', metavar='networks', type=str, nargs='+', help='networks')
  ARGS = PARSER.parse_args()
  Router(ARGS.asn, ARGS.networks).run()
