#!/usr/bin/env python3
"""
Project 2 Milestone for CS3700
Caitlin Wang and Isabel Tripp (Team Blonco)

Based on provided starter code
"""

import argparse
import json
import select
import socket
import ipaddress

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# internal route info
CUST = "cust"
PEER = "peer"
PROV = "prov"


##########################################################################################

class Router:
  """ Router constructor """
  def __init__(self, asn, networks):
    self.asn = asn
    self.routes = {}
    self.updates = []
    self.relations = {}
    self.sockets = {}
    for relationship in networks:
      network, relation = relationship.split('-')
      self.sockets[network] = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
      self.sockets[network].setblocking(0)
      self.sockets[network].connect(network)
      self.relations[network] = relation


  def forward(self, srcif, packet):
    """ Forward a data packet """
    src = packet[SRCE]
    dst = packet[DEST]
    
    # Find the socket that matches the destination
    for net, peer in self.routes.items():
      network = net[0]
      netmask = net[1]
      dst_network = ipaddress.ip_network(dst + '/' + netmask, strict=False)
      route_network = ipaddress.ip_network(network + '/' + netmask, strict=False)
      if route_network.compare_networks(dst_network) == 0:
        # Send the packet on the correct socket
        try:
          conn = self.sockets[peer]        
          conn.sendall(json.dumps(packet).encode())
        except:
          raise Exception('Failed to forward data packet')
        return True

    return False


  def update(self, srcif, packet):
    """ Handle update packets """
    # Save copy of the route announcement
    self.updates.append(packet)

    # Update forwarding table
    src = packet[SRCE]
    dst = packet[DEST]
    aspath = packet[MESG][APTH]

    network = packet[MESG][NTWK]
    netmask = packet[MESG][NMSK]
    self.routes[(network, netmask)] = src

    # Send announcement to neighboring routers
    aspath.append(self.asn)
    packet[MESG][APTH] = aspath

    for sock, conn in self.sockets.items():
        if not src == sock:
          packet[DEST] = sock
          packet[SRCE] = (ipaddress.ip_address(sock) - 1).exploded
          try:
            conn.sendall(json.dumps(packet).encode())
          except:
            raise Exception('Failed to forward update announcement to neighbor')

    return True


  def dump(self, packet):
    """ Handles dump table requests """
    src = packet[SRCE]
    dst = packet[DEST]
    
    # Build the table message based on contents of routing table
    table_dict = []
    for net, peer in self.routes.items():
      table_item = {NTWK: net[0], NMSK: net[1], PEER: peer}
      table_dict.append(table_item)

    table_packet = {SRCE: dst, DEST: src, TYPE: 'table', MESG: table_dict}

    # Send the table packet to the router requesting it
    try:
      conn = self.sockets[src]
      conn.sendall(json.dumps(table_packet).encode())
    except:
      raise Exception('Faled to send forwarding table to requester')

    return True


  def handle_packet(self, srcif, packet):
    """ Dispatches a packet """
    status = False

    if packet[TYPE] == UPDT:
      status = self.update(srcif, packet)
    elif packet[TYPE] == DATA:
      status = self.forward(srcif, packet)
    elif packet[TYPE] == DUMP:
      status = self.dump(packet)

    return status


  def send_error(self, conn, msg):
    """ Send a no_route error message """
    packet_src = msg[SRCE]
    packet_dst = msg[DEST]
    error_msg = {SRCE: packet_src, DEST: packet_dst, TYPE: 'no route', MESG: {}}
    try:    
      conn.sendall(json.dumps(error_msg).encode())
    except:
      raise Exception('Failed to send error')


  def run(self):
    """ Main loop for the router """
    while True:
      socks = select.select(self.sockets.values(), [], [], 0.1)[0]
      for conn in socks:
        try:
          k = conn.recv(65535)
        except:
          # either died on a connection reset, or was SIGTERM's by parent
          return
        if k:
          for sock in self.sockets:
            if self.sockets[sock] == conn:
              srcif = sock
          msg = json.loads(k)
          if not self.handle_packet(srcif, msg):
            self.send_error(conn, msg)
        else:
          return


if __name__ == "__main__":
  PARSER = argparse.ArgumentParser(description='route packets')
  PARSER.add_argument('asn', type=int, help="AS number")
  PARSER.add_argument('networks', metavar='networks', type=str, nargs='+', help='networks')
  ARGS = PARSER.parse_args()
  Router(ARGS.asn, ARGS.networks).run()
