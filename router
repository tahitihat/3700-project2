#!/usr/bin/env python3
"""
Project 2 Submission for CS3700
Caitlin Wang and Isabel Tripp (Team Blonco)

Based on provided starter code
"""

import argparse
import json
import select
import socket
import ipaddress
import operator
from functools import reduce

##########################################################################################

# Message Fields
TYPE = "type"
SRCE = "src"
DEST = "dst"
MESG = "msg"
TABL = "table"

# Message Types
DATA = "data"
DUMP = "dump"
UPDT = "update"
RVKE = "revoke"
NRTE = "no route"

# Update Message Fields
NTWK = "network"
NMSK = "netmask"
ORIG = "origin"
LPRF = "localpref"
APTH = "ASPath"
SORG = "selfOrigin"

# Internal Route Info
CUST = "cust"
PEER = "peer"
PROV = "prov"

# Route Origin Info
IGP = 'IGP'
EGP = 'EGP'
UNK = 'UNK'

# Util
NXHP = 'next_hop'

##########################################################################################

class Router:
  """ Router constructor """

  def __init__(self, asn, networks):
    self.asn = asn
    self.routes = {}
    self.updates = []
    self.relations = {}
    self.sockets = {}
    for relationship in networks:
      network, relation = relationship.split('-')
      self.sockets[network] = socket.socket(
          socket.AF_UNIX, socket.SOCK_SEQPACKET)
      self.sockets[network].setblocking(0)
      self.sockets[network].connect(network)
      self.relations[network] = relation


  def lookup_routes(self, daddr):
    """ Look up all valid routes for an address """    
    longest_prefix = 0
    longest_prefix_routes = []

    for net, route in self.routes.items():
      network = net[0]
      netmask = net[1]
      next_hop = net[2]
      route_network = ipaddress.ip_network(network + '/' + netmask, strict=False)
      if ipaddress.ip_address(daddr) in route_network:
        # Longest prefix matching
        bin_mask = bin(int(ipaddress.ip_address(netmask)))
        mask_prefix_length = bin_mask.count('1')
        route[NXHP] = next_hop
        if mask_prefix_length > longest_prefix:
          longest_prefix = mask_prefix_length
          longest_prefix_routes = [route]
        elif mask_prefix_length == longest_prefix:
          longest_prefix_routes.append(route)

    return longest_prefix_routes


  def get_shortest_as_path(self, routes):
    """ Select the route with the shortest AS Path """
    outroutes = []
    shortest_len = 100000 #TODO better selection algorithm
    for route in routes:
      as_path = route[APTH]
      as_path_len = len(as_path)
      # If ASpath shorter, update outroutes and shortest_len
      if as_path_len < shortest_len:
        shortest_len = as_path_len
        outroutes = [route]
      # If ASpath equal, append route to outroutes
      elif as_path_len == shortest_len:
        outroutes.append(route)

    return outroutes


  def get_highest_preference(self, routes):
    """ Select the route with the highest localPref """
    outroutes = []
    highest_pref = 0
    for route in routes:
      localpref = route[LPRF]
      # If localpref higher, update outroutes and highest_pref
      if localpref > highest_pref:
        highest_pref = localpref
        outroutes = [route]
      # If localpref equal, append route to outroutes
      elif localpref == highest_pref:
        outroutes.append(route)

    return outroutes


  def get_self_origin(self, routes):
    """ Select self originating routes """
    sorg_routes = [route for route in routes if route[SORG]]
    return sorg_routes if len(sorg_routes) > 0 else routes


  def compare_higher_origin(self, origin1, origin2):
    """
      Compare two origins based on precedence IGP > EGP > UNK
      <0 o1 is more preferable than o2
      0 o1 is equivalent to o2
      >1 o1 is less preferable than o2
    """
    if origin1 == IGP:
      val = 0 if origin2 == IGP else -1
    elif origin1 == EGP:
      if origin2 == IGP:
        val = 1
      elif origin2 == EGP:
        val = 0
      elif origin2 == UNK:
        val = -1
    elif origin1 == UNK:
      val = 0 if origin2 == UNK else 1

    return val


  def get_origin_routes(self, routes):
    """ Select origin routes: IGP > EGP > UNK """
    outroutes = []
    best_origin = UNK
    for route in routes:
      origin = route[ORIG]
      origin_comparison = self.compare_higher_origin(origin, best_origin)
      # If origin better, update outroutes and best_origin
      if origin_comparison < 0:
        best_origin = origin
        outroutes = [route]
      # If origin equal, append route to outroutes
      elif origin_comparison == 0:
        outroutes.append(route)

    return outroutes


  def filter_relationships(self, srcif, route):
    """ Don't allow Peer->Peer, Peer->Prov, or Prov->Peer forwards """
    src_relation = self.relations[srcif]
    route_peer = route[NXHP]
    dst_relation = self.relations[route_peer]
    if (not src_relation == CUST) and (not dst_relation == CUST):
      return None
    return route


  def get_route(self, srcif, daddr):
    """ Select the best route for a given address """
    routes = self.lookup_routes(daddr)
    peer = None
    # Rules go here
    if routes:
      # 1. Highest Preference
      routes = self.get_highest_preference(routes)
      # 2. Self Origin
      routes = self.get_self_origin(routes)
      # 3. Shortest ASPath
      routes = self.get_shortest_as_path(routes)
      # 4. EGP > IGP > UNK
      routes = self.get_origin_routes(routes)
      # 5. Lowest IP Address
      routes = [min(routes, key=lambda x: x[NXHP])]
      # Final check: enforce peering relationships
    if len(routes) > 0:
      route = self.filter_relationships(srcif, routes[0])
      peer = route[NXHP] if route else None
    return peer


  def forward(self, srcif, packet):
    """ Forward a data packet """
    dst = packet[DEST]
    # Find the socket that matches the destination
    try:
      peer = self.get_route(srcif, dst)      
      if peer is not None:
        conn = self.sockets[peer]
        conn.sendall(json.dumps(packet).encode())
      else: 
        # No route to dest, send no route error
        self.send_forward_error(srcif, packet)
    except:
      raise Exception('Failed to forward data packet')
    return True


  def send_forward_error(self, srcif, packet):
    """ Build and send a no_route error message """
    packet_dst = packet[SRCE]
    packet_src = (ipaddress.ip_address(srcif) - 1).exploded
    error_msg = {SRCE: packet_src, DEST: packet_dst, TYPE: 'no route', MESG: {}}
    try:
      conn = self.sockets[srcif]
      conn.sendall(json.dumps(error_msg).encode())
    except:
      raise Exception('Failed to send error')


  def coalesce(self):
    """ coalesce any routes that are right next to each other """
    # TODO (this is the most difficult task, save until last)

    return False


  def update(self, srcif, packet):
    """ Handle update packets """
    # Save copy of the route announcement
    self.updates.append(packet)

    # Update forwarding table
    src = packet[SRCE]
    dst = packet[DEST]

    aspath = packet[MESG][APTH]
    network = packet[MESG][NTWK]
    netmask = packet[MESG][NMSK]
    localpref = packet[MESG][LPRF]
    origin = packet[MESG][ORIG]
    self_origin = packet[MESG][SORG]

    route_info = {APTH: aspath, LPRF: localpref, ORIG: origin, SORG: self_origin}

    self.routes[(network, netmask, src)] = route_info

    # Send announcement to neighboring routers
    aspath.append(self.asn)
    packet[MESG][APTH] = aspath

    src_relation = self.relations[srcif]
    for sock, conn in self.sockets.items():
      # Don't rebroadcast to source of update
      if not src == sock:
        sock_relation = self.relations[sock]
        # Don't allow Peer->Peer, Peer->Prov, or Prov->Peer updates
        if (src_relation == CUST) or (sock_relation == CUST):
          packet[DEST] = sock
          packet[SRCE] = (ipaddress.ip_address(sock) - 1).exploded
          try:
            conn.sendall(json.dumps(packet).encode())
          except:
            raise Exception('Failed to forward update announcement to neighbor')

    return True


  def revoke(self, packet):
    """ Handle revoke packets """
    # Save copy of the revoke request
    self.updates.append(packet)

    src = packet[SRCE]
    revoked_routes = packet[MESG]

    for route in revoked_routes:
      network = route[NTWK]
      netmask = route[NMSK]
      if (network, netmask, src) not in self.routes:
        return False
      else:
        # Remove (network, netmask, src) key from self.routes
        del(self.routes[(network, netmask, src)])

    # Send announcement to neighboring routers if network now inaccessible
    for sock, conn in self.sockets.items():
        if not src == sock:
          packet[DEST] = sock
          packet[SRCE] = (ipaddress.ip_address(sock) - 1).exploded
          try:
            conn.sendall(json.dumps(packet).encode())
          except:
            raise Exception('Failed to forward update announcement to neighbor')

    return True


  def dump(self, packet):
    """ Handles dump table requests """
    src = packet[SRCE]
    dst = packet[DEST]
    
    # Build the table message based on contents of routing table
    table_dict = []
    for net, route in self.routes.items():
      table_item = {NTWK: net[0], NMSK: net[1], PEER: net[2]}
      table_dict.append(table_item)

    table_packet = {SRCE: dst, DEST: src, TYPE: 'table', MESG: table_dict}

    # Send the table packet to the router requesting it
    try:
      conn = self.sockets[src]
      conn.sendall(json.dumps(table_packet).encode())
    except:
      raise Exception('Faled to send forwarding table to requester')

    return True


  def handle_packet(self, srcif, packet):
    """ Dispatches a packet """
    status = False

    if packet[TYPE] == UPDT:
      status = self.update(srcif, packet)
    elif packet[TYPE] == DATA:
      status = self.forward(srcif, packet)
    elif packet[TYPE] == DUMP:
      status = self.dump(packet)
    elif packet[TYPE] == RVKE:
      status = self.revoke(packet)
    return status


  def print_error(self, msg):
    """ Print error message """
    print('Packet handler failed to execute.\n')
    print(msg)


  def run(self):
    """ Main loop for the router """
    while True:
      socks = select.select(self.sockets.values(), [], [], 0.1)[0]
      for conn in socks:
        try:
          k = conn.recv(65535)
        except:
          # either died on a connection reset, or was SIGTERM's by parent
          return
        if k:
          for sock in self.sockets:
            if self.sockets[sock] == conn:
              srcif = sock
          msg = json.loads(k)
          if not self.handle_packet(srcif, msg):
            self.print_error(msg)
        else:
          return


if __name__ == "__main__":
  PARSER = argparse.ArgumentParser(description='route packets')
  PARSER.add_argument('asn', type=int, help="AS number")
  PARSER.add_argument('networks', metavar='networks', type=str, nargs='+', help='networks')
  ARGS = PARSER.parse_args()
  Router(ARGS.asn, ARGS.networks).run()
